package at.tuwien.mapper;

import at.tuwien.entities.database.table.Table;
import at.tuwien.entities.database.table.columns.TableColumn;
import at.tuwien.exception.StreamException;
import at.tuwien.exception.TableMalformedException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.flink.connector.jdbc.JdbcStatementBuilder;
import org.mapstruct.Mapper;
import org.mariadb.jdbc.MariaDbBlob;
import org.springframework.transaction.annotation.Transactional;
import scala.Tuple1;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.*;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface QueryMapper {

    org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(QueryMapper.class);

    ObjectMapper objectMapper = new ObjectMapper();

    default String tableToRawInsertQuery(Table table)
            throws TableMalformedException {
        if (table.getColumns().size() == 0) {
            log.error("Column size is zero");
            throw new TableMalformedException("Columns are not known");
        }
        /* parameterized query for prepared statement */
        final int[] idx = new int[]{0};
        final StringBuilder query = new StringBuilder("INSERT INTO `")
                .append(table.getInternalName())
                .append("` (")
                .append(table.getColumns()
                        .stream()
                        .filter(column -> !column.getAutoGenerated())
                        .map(column -> "`" + column.getInternalName() + "`")
                        .collect(Collectors.joining(",")))
                .append(") VALUES (")
                .append(table.getColumns()
                        .stream()
                        .filter(column -> !column.getAutoGenerated())
                        .map(column -> "?" + idx[0]++)
                        .collect(Collectors.joining(",")))
                .append(");");
        /* debug */
        log.trace("raw insert query: [{}]", query);
        return query.toString();
    }

    default Tuple1<Object[]> stringToTuple(String data) throws StreamException {
        try {
            return new Tuple1<>(objectMapper.readValue(data.getBytes(StandardCharsets.UTF_8),
                    Object[].class));
        } catch (IOException e) {
            log.error("Failed to map input to tuple");
            throw new StreamException("Failed to map input to tuple", e);
        }
    }

    @Transactional(readOnly = true)
    default void dataColumnToObject(PreparedStatement statement, TableColumn column, Object data, Integer idx)
            throws DateTimeException, SQLException {
        if (data == null) {
            return;
        }
        log.trace("map data {} to table column {}", data, column);
        switch (column.getColumnType()) {
            case BLOB:
                log.trace("mapping {} to blob", data);
                statement.setBlob(idx, new MariaDbBlob((byte[]) data));
            case DATE:
                if (column.getDateFormat() == null) {
                    log.error("Missing date format for column {} of table {}", column.getId(), column.getTable().getId());
                    throw new IllegalArgumentException("Missing date format");
                }
                final DateTimeFormatter formatter = new DateTimeFormatterBuilder()
                        .parseCaseInsensitive() /* case insensitive to parse JAN and FEB */
                        .appendPattern(column.getDateFormat().getUnixFormat())
                        .toFormatter(Locale.ENGLISH);
                final LocalDate date = LocalDate.parse(String.valueOf(data), formatter);
                final Instant val = date.atStartOfDay(ZoneId.of("UTC"))
                        .toInstant();
                log.trace("mapping {} to date with format '{}' to value {}", data, column.getDateFormat(), val);
                statement.setDate(idx, (Date) Date.from(val));
            case ENUM:
            case TEXT:
            case STRING:
                log.trace("mapping {} to character array", data);
                statement.setString(idx, String.valueOf(data));
            case NUMBER:
                log.trace("mapping {} to non-decimal number", data);
                statement.setLong(idx, Long.parseLong(String.valueOf(data)));
            case DECIMAL:
                log.trace("mapping {} to decimal number", data);
                statement.setDouble(idx, Double.parseDouble(String.valueOf(data)));
            case BOOLEAN:
                statement.setBoolean(idx, Boolean.parseBoolean(String.valueOf(data)));
            default:
                throw new IllegalArgumentException("Column type not known");
        }
    }

    default JdbcStatementBuilder<Tuple1<Object[]>> tableToJdbcStatementBuilder(Table table) {
        final int[] idx = new int[]{0};
        final JdbcStatementBuilder<Tuple1<Object[]>> builder = (statement, entity) -> table.getColumns()
                .forEach(column -> {
                    try {
                        dataColumnToObject(statement, column, entity, idx[0]++);
                    } catch (SQLException e) {
                        log.error("Failed to map tuple to object: {}", e.getMessage());
                        /* can only ignore from here */
                    }
                });
        return builder;
    }
}
