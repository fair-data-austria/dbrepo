package at.tuwien.mapper;

import at.tuwien.InsertTableRawQuery;
import at.tuwien.api.database.query.*;
import at.tuwien.api.database.table.TableCsvDto;
import at.tuwien.exception.TableMalformedException;
import at.tuwien.querystore.Query;
import at.tuwien.entities.database.table.Table;
import at.tuwien.entities.database.table.columns.TableColumn;
import at.tuwien.exception.ImageNotSupportedException;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.Named;
import org.mariadb.jdbc.MariaDbBlob;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigInteger;
import java.text.Normalizer;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Mapper(componentModel = "spring")
public interface QueryMapper {

    org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(QueryMapper.class);

    @Mappings({
            @Mapping(source = "query", target = "statement")
    })
    ExecuteStatementDto queryDtoToExecuteStatementDto(QueryDto data);

    ExecuteStatementDto saveStatementDtoToExecuteStatementDto(SaveStatementDto data);

    QueryDto queryToQueryDto(Query data);

    List<QueryDto> queryListToQueryDtoList(List<Query> data);

    @Named("internalMapping")
    default String nameToInternalName(String data) {
        if (data == null || data.length() == 0) {
            return data;
        }
        final Pattern NONLATIN = Pattern.compile("[^\\w-]");
        final Pattern WHITESPACE = Pattern.compile("[\\s]");
        String nowhitespace = WHITESPACE.matcher(data).replaceAll("_");
        String normalized = Normalizer.normalize(nowhitespace, Normalizer.Form.NFD);
        String slug = NONLATIN.matcher(normalized).replaceAll("");
        return slug.toLowerCase(Locale.ENGLISH);
    }

    default QueryResultDto resultListToQueryResultDto(List<TableColumn> columns, List<?> result) {
        final Iterator<?> iterator = result.iterator();
        final List<Map<String, Object>> resultList = new LinkedList<>();
        while (iterator.hasNext()) {
            /* map the result set to the columns through the stored metadata in the metadata database */
            int[] idx = new int[]{0};
            final Object[] data;
            if (columns.size() == 1) {
                /* issue #135 */
                data = new Object[]{iterator.next()};
            } else {
                data = (Object[]) iterator.next();
            }
            final Map<String, Object> map = new HashMap<>();
            columns
                    .forEach(column -> map.put(column.getName(),
                            dataColumnToObject(data[idx[0]++], column)));
            resultList.add(map);
        }
        return QueryResultDto.builder()
                .result(resultList)
                .build();
    }

    default InsertTableRawQuery pathToRawInsertQuery(Table table, ImportDto data) {
        final StringBuilder query = new StringBuilder("LOAD DATA LOCAL INFILE '")
                .append(data.getLocation())
                .append("' INTO TABLE `")
                .append(table.getDatabase().getInternalName())
                .append("`.`")
                .append(table.getInternalName())
                .append("` CHARACTER SET utf8 FIELDS TERMINATED BY '")
                .append(table.getSeparator())
                .append("'")
                .append(table.getSkipLines() != null ? (" IGNORE " + table.getSkipLines() + " LINES") : "")
                .append(" (");
        final StringBuilder dateSet = new StringBuilder();
        int[] idx = new int[]{0};
        table.getColumns()
                .forEach(column -> {
                    if (column.getAutoGenerated()) {
                        return;
                    }
                    query.append(idx[0] != 0 ? "," : "");
                    if (column.getDateFormat() != null) {
                        /* format date as variable */
                        query.append("@")
                                .append(column.getInternalName());
                        /* reformat the date variable as well */
                        dateSet.append(dateSet.length() != 0 ? ", " : "")
                                .append(column.getInternalName())
                                .append(" = ")
                                .append("STR_TO_DATE(")
                                .append("@")
                                .append(column.getInternalName())
                                .append(", '")
                                .append(column.getDateFormat()
                                        .getDatabaseFormat())
                                .append("')");
                    } else {
                        query.append("`")
                                .append(column.getInternalName())
                                .append("`");
                    }
                    idx[0]++;
                });
        query.append(")")
                .append(dateSet.length() != 0 ? (" SET " + dateSet) : "")
                .append(";");
        log.debug("import csv {} for table {}", data.getLocation(), table);
        log.trace("raw import query: [{}]", query);
        return InsertTableRawQuery.builder()
                .query(query.toString())
                .build();

    }

    default InsertTableRawQuery tableCsvDtoToRawInsertQuery(Table table, TableCsvDto data)
            throws TableMalformedException {
        if (table.getColumns().size() == 0) {
            log.error("Column size is zero");
            throw new TableMalformedException("Columns are not known");
        }
        /* parameterized query for prepared statement */
        final StringBuilder query = new StringBuilder("INSERT INTO `")
                .append(table.getInternalName())
                .append("` (")
                .append(table.getColumns()
                        .stream()
                        .filter(column -> !column.getAutoGenerated())
                        .map(column -> "`" + column.getInternalName() + "`")
                        .collect(Collectors.joining(",")))
                .append(") VALUES (?1);");
        /* debug */
        log.trace("raw insert query: [{}] with data {}", query, data.getData().values());
        return InsertTableRawQuery.builder()
                .query(query.toString())
                .data(data.getData().values())
                .build();
    }

    default String tableToRawCountAllQuery(Table table, Instant timestamp) throws ImageNotSupportedException {
        /* param check */
        if (!table.getDatabase().getContainer().getImage().getRepository().equals("mariadb")) {
            throw new ImageNotSupportedException("Currently only MariaDB is supported");
        }
        if (timestamp == null) {
            timestamp = Instant.now();
        }
        return "SELECT COUNT(*) FROM `" + nameToInternalName(table.getName()) +
                "` FOR SYSTEM_TIME AS OF TIMESTAMP'" +
                LocalDateTime.ofInstant(timestamp, ZoneId.of("Europe/Vienna")) +
                "';";
    }

    default String tableToRawFindAllQuery(Table table, Instant timestamp, Long size, Long page, String sortBy,
                                          Boolean sortDesc)
            throws ImageNotSupportedException {
        /* param check */
        if (!table.getDatabase().getContainer().getImage().getRepository().equals("mariadb")) {
            throw new ImageNotSupportedException("Currently only MariaDB is supported");
        }
        if (timestamp == null) {
            timestamp = Instant.now();
            log.trace("no timestamp provided, default to {}", timestamp);
        } else {
            log.debug("timestamp provided {}", timestamp);
        }
        final int[] idx = new int[]{0};
        final StringBuilder query = new StringBuilder("SELECT ");
        table.getColumns()
                .forEach(column -> query.append(idx[0]++ > 0 ? "," : "")
                        .append("`")
                        .append(column.getInternalName())
                        .append("`"));
        query.append(" FROM `")
                .append(nameToInternalName(table.getName()))
                .append("` FOR SYSTEM_TIME AS OF TIMESTAMP'")
                .append(LocalDateTime.ofInstant(timestamp, ZoneId.of("Europe/Vienna")))
                .append("'");
        if (sortBy != null && sortDesc != null) {
            /* sorting requested */
            query.append(" ORDER BY ")
                    .append("`")
                    .append(sortBy)
                    .append("` ")
                    .append(sortDesc ? "DESC" : "ASC");
        }
        if (size != null && page != null) {
            log.trace("pagination size/limit of {}", size);
            query.append(" LIMIT ")
                    .append(size);
            log.trace("pagination page/offset of {}", page);
            query.append(" OFFSET ")
                    .append(page * size)
                    .append(";");

        }
        log.trace("raw select table query: [{}]", query);
        return query.toString();
    }

    /**
     * Map the result list with table.
     * <p>
     * We have a special case in MariaDB where when the result is only (id=1),(id=2),... the {@link Iterator#next()}
     * function only returns a single entity instead of a list.
     *
     * @param result The result list.
     * @param table  The table.
     * @return Result of the query execution.
     * @throws DateTimeException
     */
    default QueryResultDto queryTableToQueryResultDto(List<?> result, Table table) throws DateTimeException {
        final Iterator<?> iterator = result.iterator();
        final List<Map<String, Object>> queryResult = new LinkedList<>();
        while (iterator.hasNext()) {
            /* map the result set to the columns through the stored metadata in the metadata database */
            int[] idx = new int[]{0};
            final Object[] data;
            if (table.getColumns().size() == 1 && table.getColumns().get(0).getIsPrimaryKey()) {
                /* special MariaDB case */
                data = new Object[]{iterator.next()};
            } else {
                data = (Object[]) iterator.next();
            }
            final Map<String, Object> map = new HashMap<>();
            table.getColumns()
                    .forEach(column -> map.put(column.getInternalName(), dataColumnToObject(data[idx[0]++], column)));
            queryResult.add(map);
        }
        log.debug("selected {} records from table id {}", queryResult.size(), table.getId());
        log.trace("table {} contains {} records", table, queryResult.size());
        return QueryResultDto.builder()
                .result(queryResult)
                .build();
    }

    @Transactional
    default Object dataColumnToObject(Object data, TableColumn column) throws DateTimeException {
        if (data == null) {
            return null;
        }
        log.trace("map data {} to table column {}", data, column);
        switch (column.getColumnType()) {
            case BLOB:
                log.trace("mapping {} to blob", data);
                return new MariaDbBlob((byte[]) data);
            case DATE:
                if (column.getDateFormat() == null) {
                    log.error("Missing date format for column {} of table {}", column.getId(), column.getTable().getId());
                    throw new IllegalArgumentException("Missing date format");
                }
                final DateTimeFormatter formatter = new DateTimeFormatterBuilder()
                        .parseCaseInsensitive() /* case insensitive to parse JAN and FEB */
                        .appendPattern(column.getDateFormat().getUnixFormat())
                        .toFormatter(Locale.ENGLISH);
                final LocalDate date = LocalDate.parse(String.valueOf(data), formatter);
                final Instant val = date.atStartOfDay(ZoneId.of("UTC"))
                        .toInstant();
                log.trace("mapping {} to date with format '{}' to value {}", data, column.getDateFormat(), val);
                return val;
            case ENUM:
                log.trace("mapping {} to enum", data);
                return String.valueOf(data);
            case TEXT:
                log.trace("mapping {} to text", data);
                return String.valueOf(data);
            case STRING:
                log.trace("mapping {} to character array", data);
                return String.valueOf(data);
            case NUMBER:
                log.trace("mapping {} to integer number", data);
                return new BigInteger(String.valueOf(data));
            case DECIMAL:
                log.trace("mapping {} to decimal number", data);
                return Double.valueOf(String.valueOf(data));
            case BOOLEAN:
                log.trace("mapping {} to boolean", data);
                return Boolean.valueOf(String.valueOf(data));
            default:
                throw new IllegalArgumentException("Column type not known");
        }
    }
}
